http://downloads.sourceforge.net/gnuwin32/grep-2.5.4-bin.ziphttps://github.com/nscaife/file-windows/releases/download/20170108/file-windows-20170108.ziphttp://sourceforge.net/projects/gnuwin32/files//sed/4.2.1/sed-4.2.1-bin.zip/download//file -b --mime-type filename | sed 's|/.*||'//in command <type> in windows there is a line read as://This program cannot be run in DOS mode.//for binary (non-text) files//also there is file_type in c++//#include <cstdio>//#include <cstring>//#include <filesystem>//#include <fstream>//#include <iostream>//#include <sys/socket.h>//#include <sys/stat.h>//#include <sys/un.h>//#include <unistd.h>// //namespace fs = std::filesystem;// //void demo_status(const fs::path& p, fs::file_status s)//{//    std::cout << p;//    switch (s.type())//    {//        case fs::file_type::none://            std::cout << " has `not-evaluated-yet` type";//            break;//        case fs::file_type::not_found://            std::cout << " does not exist";//            break;//        case fs::file_type::regular://            std::cout << " is a regular file";//            break;//        case fs::file_type::directory://            std::cout << " is a directory";//            break;//        case fs::file_type::symlink://            std::cout << " is a symlink";//            break;//        case fs::file_type::block://            std::cout << " is a block device";//            break;//        case fs::file_type::character://            std::cout << " is a character device";//            break;//        case fs::file_type::fifo://            std::cout << " is a named IPC pipe";//            break;//        case fs::file_type::socket://            std::cout << " is a named IPC socket";//            break;//        case fs::file_type::unknown://            std::cout << " has `unknown` type";//            break;//        default://            std::cout << " has `implementation-defined` type";//            break;//    }//    std::cout << '\n';//}// //int main()//{//    // create files of different kinds//    fs::create_directory("sandbox");//    fs::create_directory("sandbox/dir");//    std::ofstream{"sandbox/file"}; // create regular file//    fs::create_symlink("file", "sandbox/symlink");// //    mkfifo("sandbox/pipe", 0644);//    sockaddr_un addr;//    addr.sun_family = AF_UNIX;//    std::strcpy(addr.sun_path, "sandbox/sock");//    int fd = socket(PF_UNIX, SOCK_STREAM, 0);//    bind(fd, reinterpret_cast<sockaddr*>(&addr), sizeof addr);// //    // demo different status accessors//    for (auto it{fs::directory_iterator("sandbox")}; it != fs::directory_iterator(); ++it)//        demo_status(*it, it->symlink_status()); // use cached status from directory entry//    demo_status("/dev/null", fs::status("/dev/null")); // direct calls to status//    demo_status("/dev/sda", fs::status("/dev/sda"));//    demo_status("sandbox/no", fs::status("/sandbox/no"));// //    // cleanup (prefer std::unique_ptr-based custom deleters)//    close(fd);//    fs::remove_all("sandbox");//}bool is_ascii(string arg1) { /* variable(s) [v1] input-file [v2] temporary-text-file */ string cmd = mark("blue", "[] "); string err1 = mark("yellow", "[WARNING] "); // string v1 = arg1; string v2 = ts(); // command(s) string cmd1 = "echo `file -b --mime-type " + quote(v1) + "` > " + v2; // op(s) if (not write_access()) {  cout << err1 + "write-permission denied!" << endl;  exit(1); } int e = sys(cmd1); if (split((cat(v2).txt).substr(0, (cat(v2).txt).size() - 1), "/")[0] == "text") {  rm(v2);  return 1; } else {  rm(v2);  return 0; }}int main(int argc, char* argv[]) { string v1 = argv[1]; v1 = can(v1); vector<string> v2 = {}; v2 = tree(v1, true); for (int i = 0; i < v2.size(); i++)  if (is_ascii(v2[i])) {   if (has(v2[i], "'")) {    cout << mark("yellow", "[NAMIN'] ") + uri(v2[i])[0] + mark("yellow", uri(v2[i])[1]) << endl;    continue;   }   sys("awk 'sub(\"$\", \"\\r\")' " + quote(v2[i]) + " > " + quote(uri(v2[i])[0] + uri(v2[i])[2] + "_win" + uri(v2[i])[3]));   rm(v2[i]);   sys("mv " + quote(uri(v2[i])[0] + uri(v2[i])[2] + "_win" + uri(v2[i])[3]) + " " + quote(v2[i]));  }}